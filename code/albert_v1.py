{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dd657bbb",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Interface Streamlit pour l'Agent SQL avec historique et chat interactif\n",
    "Lancer avec : streamlit run app.py\n",
    "\"\"\"\n",
    "\n",
    "import streamlit as st\n",
    "import os\n",
    "import json\n",
    "import sqlite3\n",
    "import requests\n",
    "from typing import TypedDict, Annotated, Sequence, Literal\n",
    "from langchain_core.tools import tool\n",
    "from langchain_core.messages import AIMessage, HumanMessage, BaseMessage\n",
    "from langchain_openai import ChatOpenAI\n",
    "from langchain_community.tools import DuckDuckGoSearchResults\n",
    "from langgraph.graph import StateGraph, START, END\n",
    "from langgraph.graph.message import add_messages\n",
    "\n",
    "# === CONFIGURATION PAGE ===\n",
    "st.set_page_config(\n",
    "    page_title=\"ðŸŽ¬ Agent SQL Netflix\",\n",
    "    page_icon=\"ðŸ¤–\",\n",
    "    layout=\"wide\",\n",
    "    initial_sidebar_state=\"expanded\"\n",
    ")\n",
    "\n",
    "# === STYLE CSS ===\n",
    "st.markdown(\"\"\"\n",
    "<style>\n",
    "    .stChatMessage {\n",
    "        padding: 1rem;\n",
    "        border-radius: 0.5rem;\n",
    "        margin-bottom: 1rem;\n",
    "    }\n",
    "    .user-message {\n",
    "        background-color: #e3f2fd;\n",
    "    }\n",
    "    .assistant-message {\n",
    "        background-color: #f5f5f5;\n",
    "    }\n",
    "    .tool-message {\n",
    "        background-color: #fff3e0;\n",
    "        font-family: monospace;\n",
    "        font-size: 0.9em;\n",
    "    }\n",
    "</style>\n",
    "\"\"\", unsafe_allow_html=True)\n",
    "\n",
    "# === CONFIGURATION API (Sidebar) ===\n",
    "with st.sidebar:\n",
    "    st.title(\"âš™ï¸ Configuration\")\n",
    "    \n",
    "    openai_key = st.text_input(\n",
    "        \"ðŸ”‘ OpenAI API Key\",\n",
    "        type=\"password\",\n",
    "        value=os.getenv(\"OPENAI_API_KEY\", \"\"),\n",
    "        help=\"Votre clÃ© API OpenAI\"\n",
    "    )\n",
    "    \n",
    "    omdb_key = st.text_input(\n",
    "        \"ðŸŽ¬ OMDb API Key\",\n",
    "        type=\"password\",\n",
    "        value=os.getenv(\"OMDB_API_KEY\", \"\"),\n",
    "        help=\"ClÃ© API pour Open Movie Database (optionnel)\"\n",
    "    )\n",
    "    \n",
    "    db_path = st.text_input(\n",
    "        \"ðŸ“ Chemin vers la base\",\n",
    "        value=\"../data/netflix.db\",\n",
    "        help=\"Chemin vers votre fichier netflix.db\"\n",
    "    )\n",
    "    \n",
    "    st.divider()\n",
    "    \n",
    "    # Bouton pour effacer l'historique\n",
    "    if st.button(\"ðŸ—‘ï¸ Effacer l'historique\", use_container_width=True):\n",
    "        st.session_state.chat_history = []\n",
    "        st.session_state.agent_state = None\n",
    "        st.rerun()\n",
    "    \n",
    "    st.divider()\n",
    "    \n",
    "    # Informations\n",
    "    st.markdown(\"### ðŸ“Š Outils disponibles\")\n",
    "    st.markdown(\"\"\"\n",
    "    - **SQL Query** : Interroger netflix.db\n",
    "    - **Web Search** : Recherche sur le web\n",
    "    - **OMDb API** : Infos films/sÃ©ries\n",
    "    \"\"\")\n",
    "    \n",
    "    # Statut de la base\n",
    "    st.divider()\n",
    "    if os.path.exists(db_path):\n",
    "        st.success(f\"âœ… Base trouvÃ©e : `{os.path.basename(db_path)}`\")\n",
    "    else:\n",
    "        st.error(f\"âŒ Base introuvable : `{db_path}`\")\n",
    "\n",
    "# === VÃ‰RIFICATION CLÃ‰S ===\n",
    "if not openai_key:\n",
    "    st.warning(\"âš ï¸ Veuillez entrer votre clÃ© OpenAI dans la sidebar\")\n",
    "    st.stop()\n",
    "\n",
    "# === CONFIGURATION LLM ===\n",
    "OMDB_BASE_URL = \"http://www.omdbapi.com/\"\n",
    "llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0, api_key=openai_key)\n",
    "\n",
    "# === Ã‰TAT AGENT ===\n",
    "class AgentState(TypedDict):\n",
    "    messages: Annotated[Sequence[BaseMessage], add_messages]\n",
    "    schema: str\n",
    "    next_tool: str\n",
    "\n",
    "# === OUTILS ===\n",
    "@tool\n",
    "def get_db_schema(db_folder: str = \"../data\") -> str:\n",
    "    \"\"\"RÃ©cupÃ¨re le schÃ©ma de toutes les bases SQLite du dossier.\"\"\"\n",
    "    result = {\"databases\": [], \"error\": None}\n",
    "    \n",
    "    try:\n",
    "        db_files = [f for f in os.listdir(db_folder) if f.endswith(('.db', '.sqlite', '.sqlite3'))]\n",
    "    except FileNotFoundError:\n",
    "        return json.dumps({\"error\": f\"Dossier {db_folder} introuvable\"})\n",
    "    \n",
    "    if not db_files:\n",
    "        return json.dumps({\"error\": \"Aucune base SQLite trouvÃ©e\"})\n",
    "    \n",
    "    for db_file in db_files:\n",
    "        db_path_full = os.path.join(db_folder, db_file)\n",
    "        try:\n",
    "            conn = sqlite3.connect(db_path_full)\n",
    "            cursor = conn.cursor()\n",
    "            \n",
    "            database = {\"name\": db_file, \"tables\": []}\n",
    "            cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n",
    "            tables = cursor.fetchall()\n",
    "            \n",
    "            for (table_name,) in tables:\n",
    "                cursor.execute(f\"PRAGMA table_info({table_name})\")\n",
    "                columns = [{\"name\": col[1], \"type\": col[2]} for col in cursor.fetchall()]\n",
    "                database[\"tables\"].append({\"name\": table_name, \"columns\": columns})\n",
    "            \n",
    "            result[\"databases\"].append(database)\n",
    "            conn.close()\n",
    "        except Exception as e:\n",
    "            result[\"databases\"].append({\"name\": db_file, \"error\": str(e)})\n",
    "    \n",
    "    return json.dumps(result, indent=2)\n",
    "\n",
    "@tool\n",
    "def execute_sql_query(query: str, db_file_path: str = None) -> str:\n",
    "    \"\"\"ExÃ©cute une requÃªte SQL sur la base netflix.\"\"\"\n",
    "    # Utiliser le chemin de la sidebar\n",
    "    path = db_file_path or db_path\n",
    "    \n",
    "    if not os.path.exists(path):\n",
    "        return json.dumps({\"error\": f\"Base {path} introuvable\"})\n",
    "    \n",
    "    try:\n",
    "        conn = sqlite3.connect(path)\n",
    "        cursor = conn.cursor()\n",
    "        cursor.execute(query)\n",
    "        rows = cursor.fetchall()\n",
    "        columns = [desc[0] for desc in cursor.description]\n",
    "        result = [dict(zip(columns, row)) for row in rows]\n",
    "        conn.close()\n",
    "        return json.dumps(result, indent=2, default=str)\n",
    "    except Exception as e:\n",
    "        return json.dumps({\"error\": f\"Erreur SQL: {str(e)}\"})\n",
    "\n",
    "@tool\n",
    "def web_search(query: str, num_results: int = 5) -> str:\n",
    "    \"\"\"Recherche web via DuckDuckGo.\"\"\"\n",
    "    try:\n",
    "        search = DuckDuckGoSearchResults(num_results=num_results)\n",
    "        return search.run(query)\n",
    "    except Exception as e:\n",
    "        return json.dumps({\"error\": f\"Erreur web search: {str(e)}\"})\n",
    "\n",
    "@tool\n",
    "def omdb_api(by: str = \"search\", i: str = None, t: str = None, \n",
    "             s: str = None, y: str = None, plot: str = \"short\") -> str:\n",
    "    \"\"\"Interroge l'API OMDb pour infos films/sÃ©ries.\"\"\"\n",
    "    if not omdb_key:\n",
    "        return json.dumps({\"error\": \"ClÃ© OMDB_API_KEY manquante\"})\n",
    "    \n",
    "    params = {\"apikey\": omdb_key, \"plot\": plot}\n",
    "    \n",
    "    if by == \"id\" and i:\n",
    "        params[\"i\"] = i\n",
    "    elif by == \"title\" and t:\n",
    "        params[\"t\"] = t\n",
    "    elif by == \"search\" and s:\n",
    "        params[\"s\"] = s\n",
    "    else:\n",
    "        return json.dumps({\"error\": \"ParamÃ¨tres manquants (i/t/s selon 'by')\"})\n",
    "    \n",
    "    if y:\n",
    "        params[\"y\"] = y\n",
    "    \n",
    "    try:\n",
    "        response = requests.get(OMDB_BASE_URL, params=params, timeout=10)\n",
    "        response.raise_for_status()\n",
    "        return response.text\n",
    "    except requests.exceptions.RequestException as e:\n",
    "        return json.dumps({\"error\": f\"Erreur API OMDb: {str(e)}\"})\n",
    "\n",
    "# === BINDING OUTILS ===\n",
    "tools = [execute_sql_query, web_search, omdb_api]\n",
    "llm_with_tools = llm.bind_tools(tools)\n",
    "\n",
    "# === NÅ’UDS ===\n",
    "def get_schema_node(state: AgentState) -> dict:\n",
    "    \"\"\"Charge le schÃ©ma de la base de donnÃ©es.\"\"\"\n",
    "    folder = os.path.dirname(db_path) or \"../data\"\n",
    "    schema = get_db_schema.invoke({\"db_folder\": folder})\n",
    "    return {\n",
    "        \"schema\": schema,\n",
    "        \"messages\": [AIMessage(content=f\"âœ… SchÃ©ma chargÃ©\")]\n",
    "    }\n",
    "\n",
    "def chief_agent_node(state: AgentState) -> dict:\n",
    "    \"\"\"Le chief analyse la requÃªte et appelle l'outil appropriÃ©.\"\"\"\n",
    "    prompt = f\"\"\"Tu es un assistant SQL/donnÃ©es. Tu as accÃ¨s Ã  :\n",
    "1. execute_sql_query : pour interroger netflix.db\n",
    "2. web_search : pour recherches web gÃ©nÃ©rales\n",
    "3. omdb_api : pour infos prÃ©cises sur films/sÃ©ries\n",
    "\n",
    "SchÃ©ma disponible :\n",
    "{state['schema']}\n",
    "\n",
    "Analyse la requÃªte utilisateur et choisis L'OUTIL le plus adaptÃ©.\"\"\"\n",
    "    \n",
    "    messages = [{\"role\": \"system\", \"content\": prompt}] + [\n",
    "        {\"role\": m.type, \"content\": m.content} for m in state[\"messages\"]\n",
    "    ]\n",
    "    \n",
    "    response = llm_with_tools.invoke(messages)\n",
    "    \n",
    "    if response.tool_calls:\n",
    "        tool_name = response.tool_calls[0][\"name\"]\n",
    "        next_tool = {\n",
    "            \"execute_sql_query\": \"sql\",\n",
    "            \"web_search\": \"web\",\n",
    "            \"omdb_api\": \"omdb\"\n",
    "        }.get(tool_name, \"none\")\n",
    "        \n",
    "        return {\n",
    "            \"next_tool\": next_tool,\n",
    "            \"messages\": [response]\n",
    "        }\n",
    "    else:\n",
    "        return {\n",
    "            \"next_tool\": \"none\",\n",
    "            \"messages\": [response]\n",
    "        }\n",
    "\n",
    "def tool_executor_node(state: AgentState) -> dict:\n",
    "    \"\"\"ExÃ©cute l'outil choisi par le chief.\"\"\"\n",
    "    last_message = state[\"messages\"][-1]\n",
    "    \n",
    "    if not hasattr(last_message, \"tool_calls\") or not last_message.tool_calls:\n",
    "        return {\"messages\": [AIMessage(content=\"âš ï¸ Aucun outil Ã  exÃ©cuter\")]}\n",
    "    \n",
    "    tool_call = last_message.tool_calls[0]\n",
    "    tool_name = tool_call[\"name\"]\n",
    "    tool_args = tool_call[\"args\"]\n",
    "    \n",
    "    # Ajouter le chemin de la DB si nÃ©cessaire\n",
    "    if tool_name == \"execute_sql_query\" and \"db_file_path\" not in tool_args:\n",
    "        tool_args[\"db_file_path\"] = db_path\n",
    "    \n",
    "    tool_map = {\n",
    "        \"execute_sql_query\": execute_sql_query,\n",
    "        \"web_search\": web_search,\n",
    "        \"omdb_api\": omdb_api\n",
    "    }\n",
    "    \n",
    "    tool_func = tool_map.get(tool_name)\n",
    "    if not tool_func:\n",
    "        return {\"messages\": [AIMessage(content=f\"âš ï¸ Outil {tool_name} inconnu\")]}\n",
    "    \n",
    "    try:\n",
    "        result = tool_func.invoke(tool_args)\n",
    "        return {\"messages\": [AIMessage(content=f\"ðŸ“Š RÃ©sultat {tool_name}:\\n{result}\")]}\n",
    "    except Exception as e:\n",
    "        return {\"messages\": [AIMessage(content=f\"âŒ Erreur {tool_name}: {str(e)}\")]}\n",
    "\n",
    "def synthesize_node(state: AgentState) -> dict:\n",
    "    \"\"\"SynthÃ©tise les rÃ©sultats en rÃ©ponse finale.\"\"\"\n",
    "    prompt = \"\"\"Tu es un assistant qui synthÃ©tise les rÃ©sultats.\n",
    "Fournis une rÃ©ponse claire, concise et en franÃ§ais Ã  l'utilisateur.\n",
    "Utilise les donnÃ©es disponibles dans l'historique des messages.\"\"\"\n",
    "    \n",
    "    messages = [{\"role\": \"system\", \"content\": prompt}] + [\n",
    "        {\"role\": m.type, \"content\": m.content} for m in state[\"messages\"]\n",
    "    ]\n",
    "    \n",
    "    response = llm.invoke(messages)\n",
    "    return {\"messages\": [response]}\n",
    "\n",
    "# === ROUTING ===\n",
    "def route_after_chief(state: AgentState) -> Literal[\"tool_executor\", \"synthesize\"]:\n",
    "    return \"tool_executor\" if state[\"next_tool\"] != \"none\" else \"synthesize\"\n",
    "\n",
    "# === CONSTRUCTION DU GRAPHE ===\n",
    "@st.cache_resource\n",
    "def build_agent():\n",
    "    \"\"\"Construit et compile le graphe LangGraph (mis en cache).\"\"\"\n",
    "    workflow = StateGraph(AgentState)\n",
    "    \n",
    "    workflow.add_node(\"get_schema\", get_schema_node)\n",
    "    workflow.add_node(\"chief_agent\", chief_agent_node)\n",
    "    workflow.add_node(\"tool_executor\", tool_executor_node)\n",
    "    workflow.add_node(\"synthesize\", synthesize_node)\n",
    "    \n",
    "    workflow.add_edge(START, \"get_schema\")\n",
    "    workflow.add_edge(\"get_schema\", \"chief_agent\")\n",
    "    workflow.add_conditional_edges(\n",
    "        \"chief_agent\",\n",
    "        route_after_chief,\n",
    "        {\"tool_executor\": \"tool_executor\", \"synthesize\": \"synthesize\"}\n",
    "    )\n",
    "    workflow.add_edge(\"tool_executor\", \"synthesize\")\n",
    "    workflow.add_edge(\"synthesize\", END)\n",
    "    \n",
    "    return workflow.compile()\n",
    "\n",
    "app = build_agent()\n",
    "\n",
    "# === INITIALISATION SESSION STATE ===\n",
    "if \"chat_history\" not in st.session_state:\n",
    "    st.session_state.chat_history = []\n",
    "\n",
    "if \"agent_state\" not in st.session_state:\n",
    "    st.session_state.agent_state = None\n",
    "\n",
    "# === INTERFACE PRINCIPALE ===\n",
    "st.title(\"ðŸŽ¬ Agent SQL Netflix\")\n",
    "st.markdown(\"Posez des questions sur la base de donnÃ©es Netflix, recherchez des infos sur le web ou interrogez l'API OMDb !\")\n",
    "\n",
    "# === AFFICHAGE DE L'HISTORIQUE ===\n",
    "chat_container = st.container()\n",
    "\n",
    "with chat_container:\n",
    "    for msg in st.session_state.chat_history:\n",
    "        if msg[\"role\"] == \"user\":\n",
    "            with st.chat_message(\"user\", avatar=\"ðŸ‘¤\"):\n",
    "                st.markdown(msg[\"content\"])\n",
    "        elif msg[\"role\"] == \"assistant\":\n",
    "            with st.chat_message(\"assistant\", avatar=\"ðŸ¤–\"):\n",
    "                st.markdown(msg[\"content\"])\n",
    "        elif msg[\"role\"] == \"tool\":\n",
    "            with st.expander(f\"ðŸ”§ {msg['tool_name']}\", expanded=False):\n",
    "                st.code(msg[\"content\"], language=\"json\")\n",
    "\n",
    "# === INPUT UTILISATEUR ===\n",
    "user_input = st.chat_input(\"ðŸ’¬ Posez votre question...\", key=\"user_input\")\n",
    "\n",
    "if user_input:\n",
    "    # Ajouter le message utilisateur\n",
    "    st.session_state.chat_history.append({\n",
    "        \"role\": \"user\",\n",
    "        \"content\": user_input\n",
    "    })\n",
    "    \n",
    "    # Afficher le message immÃ©diatement\n",
    "    with st.chat_message(\"user\", avatar=\"ðŸ‘¤\"):\n",
    "        st.markdown(user_input)\n",
    "    \n",
    "    # PrÃ©parer l'Ã©tat de l'agent\n",
    "    if st.session_state.agent_state is None:\n",
    "        # Premier message\n",
    "        agent_messages = [HumanMessage(content=user_input)]\n",
    "    else:\n",
    "        # Messages prÃ©cÃ©dents + nouveau message\n",
    "        agent_messages = st.session_state.agent_state[\"messages\"] + [HumanMessage(content=user_input)]\n",
    "    \n",
    "    inputs = {\n",
    "        \"messages\": agent_messages,\n",
    "        \"schema\": st.session_state.agent_state[\"schema\"] if st.session_state.agent_state else \"\",\n",
    "        \"next_tool\": \"\"\n",
    "    }\n",
    "    \n",
    "    # Placeholder pour la rÃ©ponse en streaming\n",
    "    with st.chat_message(\"assistant\", avatar=\"ðŸ¤–\"):\n",
    "        response_placeholder = st.empty()\n",
    "        tool_placeholder = st.container()\n",
    "        \n",
    "        response_text = \"\"\n",
    "        \n",
    "        # ExÃ©cuter l'agent\n",
    "        with st.spinner(\"ðŸ¤” RÃ©flexion en cours...\"):\n",
    "            for step in app.stream(inputs, stream_mode=\"values\"):\n",
    "                last_msg = step[\"messages\"][-1]\n",
    "                \n",
    "                # Afficher les Ã©tapes intermÃ©diaires\n",
    "                if last_msg.type == \"ai\":\n",
    "                    # VÃ©rifier si c'est un appel d'outil\n",
    "                    if hasattr(last_msg, \"tool_calls\") and last_msg.tool_calls:\n",
    "                        tool_call = last_msg.tool_calls[0]\n",
    "                        with tool_placeholder.expander(f\"ðŸ”§ Appel : {tool_call['name']}\", expanded=False):\n",
    "                            st.json(tool_call[\"args\"])\n",
    "                    else:\n",
    "                        # RÃ©ponse finale\n",
    "                        response_text = last_msg.content\n",
    "                        response_placeholder.markdown(response_text)\n",
    "        \n",
    "        # Sauvegarder la rÃ©ponse finale\n",
    "        if response_text:\n",
    "            st.session_state.chat_history.append({\n",
    "                \"role\": \"assistant\",\n",
    "                \"content\": response_text\n",
    "            })\n",
    "        \n",
    "        # Sauvegarder l'Ã©tat de l'agent\n",
    "        st.session_state.agent_state = step\n",
    "\n",
    "# === EXEMPLES DE QUESTIONS ===\n",
    "with st.expander(\"ðŸ’¡ Exemples de questions\", expanded=False):\n",
    "    st.markdown(\"\"\"\n",
    "    **SQL Database :**\n",
    "    - Combien de films de 2020 dans la base ?\n",
    "    - Quels sont les 5 films les mieux notÃ©s ?\n",
    "    - Liste les rÃ©alisateurs qui ont fait plus de 3 films\n",
    "    \n",
    "    **Web Search :**\n",
    "    - Quelles sont les sorties Netflix de cette semaine ?\n",
    "    - Qui a gagnÃ© l'Oscar du meilleur film cette annÃ©e ?\n",
    "    \n",
    "    **OMDb API :**\n",
    "    - Donne-moi les infos complÃ¨tes sur \"Inception\"\n",
    "    - Quel est le rÃ©alisateur de \"The Dark Knight\" ?\n",
    "    - Recherche des films avec \"Matrix\" dans le titre\n",
    "    \"\"\")\n",
    "\n",
    "# === FOOTER ===\n",
    "st.divider()\n",
    "st.markdown(\"\"\"\n",
    "<div style='text-align: center; color: #666; font-size: 0.9em;'>\n",
    "    PropulsÃ© par LangGraph + Streamlit | ðŸ¤– Agent SQL Netflix\n",
    "</div>\n",
    "\"\"\", unsafe_allow_html=True)"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
